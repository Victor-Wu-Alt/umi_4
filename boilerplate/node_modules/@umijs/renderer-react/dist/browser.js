import React, { useCallback, useEffect, useState } from 'react';
// compatible with < react@18 in @umijs/preset-umi/src/features/react
import ReactDOM from 'react-dom/client';
import { matchRoutes, Router, useRoutes } from 'react-router-dom';
import { AppContext, useAppData } from './appContext';
import { createClientRoutes } from './routes';
function BrowserRoutes(props) {
    const { history } = props;
    const [state, setState] = React.useState({
        action: history.action,
        location: history.location,
    });
    React.useLayoutEffect(() => history.listen(setState), [history]);
    React.useLayoutEffect(() => {
        function onRouteChange(opts) {
            props.pluginManager.applyPlugins({
                key: 'onRouteChange',
                type: 'event',
                args: {
                    routes: props.routes,
                    clientRoutes: props.clientRoutes,
                    location: opts.location,
                    action: opts.action,
                },
            });
        }
        history.listen(onRouteChange);
        onRouteChange({ location: state.location, action: state.action });
    }, [history, props.routes, props.clientRoutes]);
    return (React.createElement(Router, { navigator: history, location: state.location, basename: props.basename }, props.children));
}
function Routes() {
    const { clientRoutes } = useAppData();
    return useRoutes(clientRoutes);
}
export function renderClient(opts) {
    const basename = opts.basename || '/';
    const rootElement = opts.rootElement || document.getElementById('root');
    const clientRoutes = createClientRoutes({
        routesById: opts.routes,
        routeComponents: opts.routeComponents,
        loadingComponent: opts.loadingComponent,
    });
    opts.pluginManager.applyPlugins({
        key: 'patchClientRoutes',
        type: 'event',
        args: {
            routes: clientRoutes,
        },
    });
    let rootContainer = (React.createElement(BrowserRoutes, { basename: basename, pluginManager: opts.pluginManager, routes: opts.routes, clientRoutes: clientRoutes, history: opts.history },
        React.createElement(Routes, null)));
    for (const key of [
        // Lowest to the highest priority
        'innerProvider',
        'i18nProvider',
        'accessProvider',
        'dataflowProvider',
        'outerProvider',
        'rootContainer',
    ]) {
        rootContainer = opts.pluginManager.applyPlugins({
            type: 'modify',
            key: key,
            initialValue: rootContainer,
            args: {},
        });
    }
    const Browser = () => {
        const [clientLoaderData, setClientLoaderData] = useState({});
        const handleRouteChange = useCallback((p) => {
            var _a;
            // Patched routes has to id
            const matchedRouteIds = (((_a = matchRoutes(clientRoutes, p)) === null || _a === void 0 ? void 0 : _a.map(
            // @ts-ignore
            (route) => route.route.id)) || []).filter(Boolean);
            matchedRouteIds.forEach((id) => {
                // preload
                // @ts-ignore
                const manifest = window.__umi_manifest__;
                if (manifest) {
                    const routeIdReplaced = id.replace(/[\/\-]/g, '_');
                    const preloadId = 'preload-' + routeIdReplaced;
                    if (!document.getElementById(preloadId)) {
                        const key = Object.keys(manifest).find((k) => k.startsWith(routeIdReplaced + '.'));
                        if (!key)
                            return;
                        let file = manifest[key];
                        const link = document.createElement('link');
                        link.id = preloadId;
                        link.rel = 'preload';
                        link.as = 'script';
                        // publicPath already in the manifest,
                        // but if runtimePublicPath is true, we need to replace it
                        if (opts.runtimePublicPath) {
                            file = file.replace(new RegExp(`^${opts.publicPath}`), 
                            // @ts-ignore
                            window.publicPath);
                        }
                        link.href = file;
                        document.head.appendChild(link);
                    }
                }
                // client loader
                const clientLoader = opts.routes[id].clientLoader;
                if (clientLoader && !clientLoaderData[id]) {
                    clientLoader().then((data) => {
                        setClientLoaderData((d) => ({ ...d, [id]: data }));
                    });
                }
            });
        }, [clientLoaderData]);
        useEffect(() => {
            handleRouteChange(window.location.pathname);
            return opts.history.listen((e) => {
                handleRouteChange(e.location.pathname);
            });
        }, []);
        return (React.createElement(AppContext.Provider, { value: {
                routes: opts.routes,
                routeComponents: opts.routeComponents,
                clientRoutes,
                pluginManager: opts.pluginManager,
                rootElement: opts.rootElement,
                basename,
                clientLoaderData,
                preloadRoute: handleRouteChange,
            } }, rootContainer));
    };
    if (ReactDOM.createRoot) {
        ReactDOM.createRoot(rootElement).render(React.createElement(Browser, null));
    }
    else {
        // @ts-ignore
        ReactDOM.render(React.createElement(Browser, null), rootElement);
    }
}
