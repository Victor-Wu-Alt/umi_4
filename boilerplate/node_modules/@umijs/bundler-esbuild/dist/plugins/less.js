"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.aliasLessImportPath = void 0;
const less_1 = __importDefault(require("@umijs/bundler-utils/compiled/less"));
const enhanced_resolve_1 = __importDefault(require("enhanced-resolve"));
const fs_1 = require("fs");
const less_plugin_aliases_1 = __importDefault(require("less-plugin-aliases"));
const path_1 = __importDefault(require("path"));
const postcssProcess_1 = require("../utils/postcssProcess");
const sortByAffix_1 = require("../utils/sortByAffix");
const resolver = enhanced_resolve_1.default.create({
    mainFields: ['module', 'browser', 'main'],
    extensions: [
        '.json',
        '.js',
        '.jsx',
        '.ts',
        '.tsx',
        '.cjs',
        '.mjs',
        '.less',
        '.css',
    ],
    // TODO: support exports
    exportsFields: [],
});
async function resolve(context, path) {
    return new Promise((resolve, reject) => {
        resolver(context, path, (err, result) => err ? reject(err) : resolve(result));
    });
}
const aliasLessImports = async (ctx, alias, importer) => {
    const importRegex = /@import(?:\s+\((.*)\))?\s+['"](.*)['"]/;
    const globalImportRegex = /@import(?:\s+\((.*)\))?\s+['"](.*)['"]/g;
    const match = ctx.match(globalImportRegex) || [];
    for (const el of match) {
        const [imp, _, filePath] = el.match(importRegex) || [];
        let aliaPath = await (0, exports.aliasLessImportPath)(filePath, alias, importer);
        if (aliaPath) {
            ctx = ctx.replace(imp, el.replace(filePath, aliaPath));
        }
    }
    return ctx;
};
const aliasLessImportPath = async (filePath, alias, importer) => {
    // ～ 写法在 esbuild 中无实际意义
    let aliaPath = filePath.startsWith('~')
        ? filePath.replace('~', '')
        : filePath;
    const keys = (0, sortByAffix_1.sortByAffix)({ arr: Object.keys(alias), affix: '$' });
    for (const key of keys) {
        const pathSegments = aliaPath.split('/');
        if (pathSegments[0] === key) {
            pathSegments[0] = alias[key];
            aliaPath = pathSegments.join('/');
            aliaPath = path_1.default.extname(aliaPath) ? aliaPath : `${aliaPath}.less`;
            return await resolve(importer, aliaPath);
        }
    }
    return null;
};
exports.aliasLessImportPath = aliasLessImportPath;
exports.default = (options = {}) => {
    const { alias, inlineStyle, config, ...lessOptions } = options;
    return {
        name: 'less',
        setup({ onResolve, onLoad }) {
            onResolve({ filter: /\.less$/, namespace: 'file' }, async (args) => {
                let filePath = args.path;
                let isMatchedAlias = false;
                // first match alias
                if (!!alias) {
                    const aliasMatchPath = await (0, exports.aliasLessImportPath)(filePath, alias, args.path);
                    if (aliasMatchPath) {
                        isMatchedAlias = true;
                        filePath = aliasMatchPath;
                    }
                }
                // if alias not matched, identify whether import from deps (node_modules)
                if (!isMatchedAlias) {
                    const isImportFromDeps = !path_1.default.isAbsolute(filePath) && !filePath.startsWith('.');
                    if (isImportFromDeps) {
                        filePath = await resolve(process.cwd(), filePath);
                    }
                    else {
                        filePath = path_1.default.resolve(process.cwd(), path_1.default.relative(process.cwd(), args.resolveDir), args.path);
                    }
                }
                return {
                    path: filePath,
                    namespace: inlineStyle ? 'less-file' : 'file',
                };
            });
            if (inlineStyle) {
                onResolve({ filter: /\.less$/, namespace: 'less-file' }, (args) => {
                    return { path: args.path, namespace: 'less-content' };
                });
                onResolve({ filter: /^__style_helper__$/, namespace: 'less-file' }, (args) => ({
                    path: args.path,
                    namespace: 'style-helper',
                    sideEffects: false,
                }));
                onLoad({ filter: /.*/, namespace: 'less-file' }, async (args) => ({
                    contents: `
            import { injectStyle } from "__style_helper__"
            import css from ${JSON.stringify(args.path)}
            injectStyle(css)
            export default{}
          `,
                }));
            }
            onLoad({ filter: /\.less$/, namespace: inlineStyle ? 'less-content' : 'file' }, async (args) => {
                let content = await fs_1.promises.readFile(args.path, 'utf-8');
                if (!!alias) {
                    content = await aliasLessImports(content, alias, args.path);
                }
                const dir = path_1.default.dirname(args.path);
                const filename = path_1.default.basename(args.path);
                try {
                    const result = await less_1.default.render(content, {
                        plugins: [
                            new less_plugin_aliases_1.default({
                                prefix: '~',
                                aliases: alias || {},
                            }),
                        ],
                        filename,
                        rootpath: dir,
                        ...lessOptions,
                        paths: [...(lessOptions.paths || []), dir],
                    });
                    const postcssrResult = await (0, postcssProcess_1.postcssProcess)(config, result.css, args.path);
                    return {
                        contents: postcssrResult.css,
                        loader: inlineStyle ? 'text' : 'css',
                        resolveDir: dir,
                    };
                }
                catch (error) {
                    return {
                        errors: [
                            {
                                text: error.message,
                                location: {
                                    namespace: 'file',
                                    file: error.filename,
                                    line: error.line,
                                    column: error.column,
                                },
                            },
                        ],
                        resolveDir: dir,
                    };
                }
            });
        },
    };
};
