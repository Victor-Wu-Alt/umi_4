"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRequestHandler = exports.getMarkup = void 0;
const react_1 = __importDefault(require("react"));
const server_1 = __importDefault(require("react-dom/server"));
// import { matchRoutes } from 'react-router-dom';
// import { createServerRoutes } from './routes';
const scripts_1 = require("./scripts");
const styles_1 = require("./styles");
async function getMarkup(opts) {
    // TODO: use real component
    let markup = server_1.default.renderToString(react_1.default.createElement('div', { id: opts.mountElementId || 'root' }));
    function propsToString(opts) {
        return Object.keys(opts.props)
            .filter((key) => !(opts.filters || []).includes(key))
            .map((key) => `${key}=${JSON.stringify(opts.props[key])}`)
            .join(' ');
    }
    function getScriptContent(script) {
        const attrs = propsToString({
            props: script,
            filters: ['src', 'content'],
        });
        return script.src
            ? `<script${opts.esmScript ? ' type="module"' : ''} ${attrs} src="${script.src}"></script>`
            : `<script${opts.esmScript ? ' type="module"' : ''} ${attrs}>${script.content}</script>`;
    }
    function getStyleContent(style) {
        const attrs = propsToString({
            props: style,
            filters: ['src', 'content'],
        });
        return style.src
            ? `<link rel="stylesheet" ${attrs} href="${style.src}" />`
            : `<style ${attrs}>${style.content}</style>`;
    }
    function getTagContent(opts) {
        const attrs = propsToString({
            props: opts.attrs,
        });
        return `<${opts.tagName} ${attrs} />`;
    }
    const favicons = [];
    if (Array.isArray(opts.favicons)) {
        opts.favicons.forEach((e) => {
            favicons.push(`<link rel="shortcut icon" href="${e}">`);
        });
    }
    const title = opts.title ? `<title>${opts.title}</title>` : '';
    const metas = (opts.metas || []).map((meta) => getTagContent({ attrs: meta, tagName: 'meta' }));
    const links = (opts.links || []).map((link) => getTagContent({ attrs: link, tagName: 'link' }));
    const styles = (0, styles_1.normalizeStyles)(opts.styles || []).map(getStyleContent);
    const headScripts = (0, scripts_1.normalizeScripts)(opts.headScripts || []).map(getScriptContent);
    const scripts = (0, scripts_1.normalizeScripts)(opts.scripts || []).map(getScriptContent);
    markup = [
        `<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<meta
  name="viewport"
  content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"
/>
<meta http-equiv="X-UA-Compatible" content="ie=edge" />`,
        metas.join('\n'),
        favicons.join('\n'),
        title,
        links.join('\n'),
        styles.join('\n'),
        headScripts.join('\n'),
        `</head>
<body>`,
        markup,
        scripts.join('\n'),
        `</body>
</html>`,
    ]
        .filter(Boolean)
        .join('\n');
    if (opts.modifyHTML) {
        markup = await opts.modifyHTML(markup, { path: opts.path });
    }
    return markup;
}
exports.getMarkup = getMarkup;
function createRequestHandler(opts) {
    return async (req, res, next) => {
        var _a;
        if (opts.historyType === 'browser' &&
            opts.base !== '/' &&
            req.path === '/') {
            // 如果是 browser，并且配置了非 / base，访问 / 时 redirect 到 base 路径
            res.redirect(opts.base);
        }
        else if ((_a = req.headers.accept) === null || _a === void 0 ? void 0 : _a.includes('text/html')) {
            // 匹配路由，不匹配走 next()
            // const routes = createServerRoutes({
            //   routesById: opts.routes,
            // });
            // const matches = matchRoutes(routes, req.path, opts.base);
            // 其他接受 HTML 的请求都兜底返回 HTML
            res.set('Content-Type', 'text/html');
            const markup = await getMarkup({ ...opts, path: req.path });
            res.end(markup);
        }
        else {
            next();
        }
    };
}
exports.createRequestHandler = createRequestHandler;
