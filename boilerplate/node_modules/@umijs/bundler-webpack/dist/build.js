"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.build = void 0;
const utils_1 = require("@umijs/utils");
const webpack_1 = __importDefault(require("../compiled/webpack"));
const config_1 = require("./config/config");
const types_1 = require("./types");
async function build(opts) {
    const webpackConfig = await (0, config_1.getConfig)({
        cwd: opts.cwd,
        rootDir: opts.rootDir,
        env: types_1.Env.production,
        entry: opts.entry,
        userConfig: opts.config,
        analyze: process.env.ANALYZE,
        babelPreset: opts.babelPreset,
        extraBabelPlugins: [
            ...(opts.beforeBabelPlugins || []),
            ...(opts.extraBabelPlugins || []),
        ],
        extraBabelPresets: [
            ...(opts.beforeBabelPresets || []),
            ...(opts.extraBabelPresets || []),
        ],
        extraBabelIncludes: opts.config.extraBabelIncludes,
        chainWebpack: opts.chainWebpack,
        modifyWebpackConfig: opts.modifyWebpackConfig,
        cache: opts.cache,
    });
    let isFirstCompile = true;
    return new Promise((resolve, reject) => {
        utils_1.rimraf.sync(webpackConfig.output.path);
        const compiler = (0, webpack_1.default)(webpackConfig);
        compiler.run((err, stats) => {
            var _a;
            (_a = opts.onBuildComplete) === null || _a === void 0 ? void 0 : _a.call(opts, {
                err,
                stats,
                isFirstCompile,
                time: stats ? stats.endTime - stats.startTime : null,
            });
            isFirstCompile = false;
            if (err || (stats === null || stats === void 0 ? void 0 : stats.hasErrors())) {
                if (err) {
                    // console.error(err);
                    reject(err);
                }
                if (stats) {
                    const errorMsg = stats.toString('errors-only');
                    // console.error(errorMsg);
                    reject(new Error(errorMsg));
                }
            }
            else {
                resolve(stats);
            }
            compiler.close(() => { });
        });
    });
}
exports.build = build;
