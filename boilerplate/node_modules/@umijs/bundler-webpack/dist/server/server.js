"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createServer = void 0;
const bundler_utils_1 = require("@umijs/bundler-utils");
const express_1 = __importDefault(require("@umijs/bundler-utils/compiled/express"));
const http_proxy_middleware_1 = require("@umijs/bundler-webpack/compiled/http-proxy-middleware");
const webpack_1 = __importDefault(require("@umijs/bundler-webpack/compiled/webpack"));
const utils_1 = require("@umijs/utils");
const cors_1 = __importDefault(require("cors"));
const fs_1 = require("fs");
const http_1 = __importDefault(require("http"));
const path_1 = require("path");
const constants_1 = require("../constants");
const ws_1 = require("./ws");
async function createServer(opts) {
    const { webpackConfig, userConfig } = opts;
    const { proxy } = userConfig;
    const app = (0, express_1.default)();
    // cros
    app.use((0, cors_1.default)({
        origin: true,
        methods: ['GET', 'HEAD', 'PUT', 'POST', 'PATCH', 'DELETE', 'OPTIONS'],
        credentials: true,
    }));
    // compression
    app.use(require('@umijs/bundler-webpack/compiled/compression')());
    // TODO: headers
    // before middlewares
    (opts.beforeMiddlewares || []).forEach((m) => app.use(m));
    // TODO: add to before middleware
    app.use((req, res, next) => {
        if (req.path === '/umi.js' && (0, fs_1.existsSync)((0, path_1.join)(opts.cwd, 'umi.js'))) {
            res.setHeader('Content-Type', 'application/javascript');
            (0, fs_1.createReadStream)((0, path_1.join)(opts.cwd, 'umi.js')).on('error', next).pipe(res);
        }
        else {
            next();
        }
    });
    // webpack dev middleware
    const configs = Array.isArray(webpackConfig)
        ? webpackConfig
        : [webpackConfig];
    const progresses = [];
    if (opts.onProgress) {
        configs.forEach((config) => {
            const progress = {
                percent: 0,
                status: 'waiting',
            };
            progresses.push(progress);
            config.plugins.push(new webpack_1.default.ProgressPlugin((percent, msg) => {
                progress.percent = percent;
                progress.status = msg;
                opts.onProgress({ progresses });
            }));
        });
    }
    const compiler = (0, webpack_1.default)(configs);
    const webpackDevMiddleware = require('@umijs/bundler-webpack/compiled/webpack-dev-middleware');
    const compilerMiddleware = webpackDevMiddleware(compiler, {
        publicPath: userConfig.publicPath || '/',
        writeToDisk: userConfig.writeToDisk,
        stats: 'none',
        // watchOptions: { ignored }
    });
    app.use(compilerMiddleware);
    // hmr hooks
    let stats;
    let isFirstCompile = true;
    compiler.compilers.forEach(addHooks);
    function addHooks(compiler) {
        compiler.hooks.invalid.tap('server', () => {
            sendMessage(constants_1.MESSAGE_TYPE.invalid);
        });
        compiler.hooks.done.tap('server', (_stats) => {
            var _a;
            stats = _stats;
            sendStats(getStats(stats));
            (_a = opts.onDevCompileDone) === null || _a === void 0 ? void 0 : _a.call(opts, {
                stats,
                isFirstCompile,
                time: stats.endTime - stats.startTime,
            });
            isFirstCompile = false;
        });
    }
    function sendStats(stats, force, sender) {
        const shouldEmit = !force &&
            stats &&
            (!stats.errors || stats.errors.length === 0) &&
            (!stats.warnings || stats.warnings.length === 0) &&
            stats.assets &&
            stats.assets.every((asset) => !asset.emitted);
        if (shouldEmit) {
            sendMessage(constants_1.MESSAGE_TYPE.stillOk, null, sender);
            return;
        }
        sendMessage(constants_1.MESSAGE_TYPE.hash, stats.hash, sender);
        if ((stats.errors && stats.errors.length > 0) ||
            (stats.warnings && stats.warnings.length > 0)) {
            if (stats.warnings && stats.warnings.length > 0) {
                sendMessage(constants_1.MESSAGE_TYPE.warnings, stats.warnings, sender);
            }
            if (stats.errors && stats.errors.length > 0) {
                sendMessage(constants_1.MESSAGE_TYPE.errors, stats.errors, sender);
            }
        }
        else {
            sendMessage(constants_1.MESSAGE_TYPE.ok, null, sender);
        }
    }
    function getStats(stats) {
        return stats.toJson({
            all: false,
            hash: true,
            assets: true,
            warnings: true,
            errors: true,
            errorDetails: false,
        });
    }
    function sendMessage(type, data, sender) {
        (sender || ws).send(JSON.stringify({ type, data }));
    }
    // mock
    // proxy
    if (proxy) {
        Object.keys(proxy).forEach((key) => {
            const proxyConfig = proxy[key];
            const target = proxyConfig.target;
            if (target) {
                app.use(key, (0, http_proxy_middleware_1.createProxyMiddleware)(key, {
                    ...proxy[key],
                    // Add x-real-url in response header
                    onProxyRes(proxyRes, req) {
                        var _a;
                        proxyRes.headers['x-real-url'] =
                            ((_a = new URL(req.url || '', target)) === null || _a === void 0 ? void 0 : _a.href) || '';
                    },
                }));
            }
        });
    }
    // after middlewares
    (opts.afterMiddlewares || []).forEach((m) => {
        // TODO: FIXME
        app.use(m.toString().includes(`{ compiler }`) ? m({ compiler }) : m);
    });
    // history fallback
    app.use(require('@umijs/bundler-webpack/compiled/connect-history-api-fallback')({
        index: '/',
    }));
    // hmr reconnect ping
    app.use('/__umi_ping', (_, res) => {
        res.end('pong');
    });
    // index.html
    // TODO: remove me
    app.get('/', (_req, res, next) => {
        res.set('Content-Type', 'text/html');
        const htmlPath = (0, path_1.join)(opts.cwd, 'index.html');
        if ((0, fs_1.existsSync)(htmlPath)) {
            (0, fs_1.createReadStream)(htmlPath).on('error', next).pipe(res);
        }
        else {
            next();
        }
    });
    const server = userConfig.https
        ? await (0, bundler_utils_1.createHttpsServer)(app, userConfig.https)
        : http_1.default.createServer(app);
    if (!server) {
        return null;
    }
    const ws = (0, ws_1.createWebSocketServer)(server);
    ws.wss.on('connection', (socket) => {
        if (stats) {
            sendStats(getStats(stats), false, socket);
        }
    });
    const protocol = userConfig.https ? 'https:' : 'http:';
    const port = opts.port || 8000;
    server.listen(port, () => {
        const host = opts.host && opts.host !== '0.0.0.0' ? opts.host : '127.0.0.1';
        utils_1.logger.ready(`App listening at ${utils_1.chalk.green(`${protocol}//${host}:${port}`)}`);
    });
    return server;
}
exports.createServer = createServer;
