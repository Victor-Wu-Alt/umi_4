"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createServer = void 0;
const bundler_utils_1 = require("@umijs/bundler-utils");
const express_1 = __importDefault(require("@umijs/bundler-utils/compiled/express"));
const utils_1 = require("@umijs/utils");
const http_1 = __importDefault(require("http"));
const vite_1 = require("../../compiled/vite");
const onHotUpdate_1 = __importDefault(require("./plugins/onHotUpdate"));
async function createServer(opts) {
    var _a, _b;
    const startTms = +new Date();
    const { viteConfig, userConfig, onDevCompileDone } = opts;
    const app = (0, express_1.default)();
    const viteConfigServer = { ...viteConfig.server };
    // 如果启用https 先获取key 和 cert 给vite ws 服务使用
    if (userConfig.https) {
        const httpsConfig = await (0, bundler_utils_1.resolveHttpsConfig)(userConfig.https);
        if (httpsConfig) {
            userConfig.https = viteConfigServer.https = {
                key: httpsConfig.key,
                cert: httpsConfig.cert,
            };
        }
    }
    const vite = await (0, vite_1.createServer)({
        ...viteConfig,
        // use `handleHotUpdate` vite hook to workaround `onDevCompileDone` umi hook
        ...(typeof onDevCompileDone === 'function'
            ? {
                plugins: viteConfig.plugins.concat([
                    (0, onHotUpdate_1.default)(async (modules) => {
                        await onDevCompileDone({
                            time: 0,
                            isFirstCompile: false,
                            stats: modules,
                        });
                    }),
                ]),
            }
            : {}),
        server: { ...viteConfigServer, middlewareMode: 'html' },
    });
    // before middlewares
    (_a = opts.beforeMiddlewares) === null || _a === void 0 ? void 0 : _a.forEach((m) => app.use(m));
    // after middlewares, insert before vite spaFallbackMiddleware
    // refer: https://github.com/vitejs/vite/blob/2c586165d7bc4b60f8bcf1f3b462b97a72cce58c/packages/vite/src/node/server/index.ts#L508
    if ((_b = opts.afterMiddlewares) === null || _b === void 0 ? void 0 : _b.length) {
        vite.middlewares.stack.some((s, i) => {
            if (s.handle.name === 'viteSpaFallbackMiddleware') {
                const afterStacks = opts.afterMiddlewares.map((m) => ({
                    route: '',
                    // TODO: FIXME
                    // see: https://github.com/umijs/umi-next/commit/34d4e4e26a20ff5c7393eab5d3db363cca541379#diff-3a996a9e7a2f94fc8f23c6efed1447eed9567e36ed622bd8547a58e5415087f7R164
                    handle: app.use(m.toString().includes(`{ compiler }`) ? m({}) : m),
                }));
                vite.middlewares.stack.splice(i, 0, ...afterStacks);
                return true;
            }
            return false;
        });
    }
    // use vite via middleware way
    app.use(vite.middlewares);
    // writeToDisk(?)
    // mock
    // prerender
    // bundless
    const server = userConfig.https
        ? await (0, bundler_utils_1.createHttpsServer)(app, userConfig.https)
        : http_1.default.createServer(app);
    if (!server) {
        return null;
    }
    const protocol = userConfig.https ? 'https:' : 'http:';
    const port = opts.port || 8000;
    server.listen(port, async () => {
        if (typeof onDevCompileDone === 'function') {
            await onDevCompileDone({
                time: +new Date() - startTms,
                isFirstCompile: true,
                // @ts-ignore
                stats: vite._optimizeDepsMetadata,
            });
        }
        const host = process.env.HOST || '127.0.0.1';
        utils_1.logger.ready(`Example app listening at ${protocol}//${host}:${port}`);
    });
    return server;
}
exports.createServer = createServer;
