"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@umijs/utils");
const fs_1 = require("fs");
const path_1 = require("path");
const constants_1 = require("../../constants");
const clearTmp_1 = require("../../utils/clearTmp");
const lazyImportFromCurrentPkg_1 = require("../../utils/lazyImportFromCurrentPkg");
const createRouteMiddleware_1 = require("./createRouteMiddleware");
const faviconMiddleware_1 = require("./faviconMiddleware");
const getBabelOpts_1 = require("./getBabelOpts");
const printMemoryUsage_1 = require("./printMemoryUsage");
const watch_1 = require("./watch");
const bundlerWebpack = (0, lazyImportFromCurrentPkg_1.lazyImportFromCurrentPkg)('@umijs/bundler-webpack');
const bundlerVite = (0, lazyImportFromCurrentPkg_1.lazyImportFromCurrentPkg)('@umijs/bundler-vite');
exports.default = (api) => {
    api.describe({
        enableBy() {
            return api.name === 'dev';
        },
    });
    api.registerCommand({
        name: 'dev',
        description: 'dev server for development',
        details: `
umi dev

# dev with specified port
PORT=8888 umi dev
`,
        async fn() {
            var _a, _b;
            utils_1.logger.info(utils_1.chalk.cyan.bold(`Umi v${api.appData.umi.version}`));
            const enableVite = !!api.config.vite;
            // clear tmp except cache
            (0, clearTmp_1.clearTmp)(api.paths.absTmpPath);
            // check package.json
            await api.applyPlugins({
                key: 'onCheckPkgJSON',
                args: {
                    origin: null,
                    current: api.appData.pkg,
                },
            });
            // clean cache if umi version not matched
            // const umiJSONPath = join(api.paths.absTmpPath, 'umi.json');
            // if (existsSync(umiJSONPath)) {
            //   const originVersion = require(umiJSONPath).version;
            //   if (originVersion !== api.appData.umi.version) {
            //     logger.info(`Delete cache folder since umi version updated.`);
            //     rimraf.sync(api.paths.absTmpPath);
            //   }
            // }
            // fsExtra.outputFileSync(
            //   umiJSONPath,
            //   JSON.stringify({ version: api.appData.umi.version }),
            // );
            // generate files
            async function generate(opts) {
                await api.applyPlugins({
                    key: 'onGenerateFiles',
                    args: {
                        files: opts.files || null,
                        isFirstTime: opts.isFirstTime,
                    },
                });
            }
            await generate({
                isFirstTime: true,
            });
            const { absPagesPath, absSrcPath } = api.paths;
            const watcherPaths = await api.applyPlugins({
                key: 'addTmpGenerateWatcherPaths',
                initialValue: [
                    absPagesPath,
                    !api.config.routes && ((_a = api.config.conventionRoutes) === null || _a === void 0 ? void 0 : _a.base),
                    (0, path_1.join)(absSrcPath, 'layouts'),
                    ...(0, watch_1.expandJSPaths)((0, path_1.join)(absSrcPath, 'loading')),
                    ...(0, watch_1.expandJSPaths)((0, path_1.join)(absSrcPath, 'app')),
                    ...(0, watch_1.expandJSPaths)((0, path_1.join)(absSrcPath, 'global')),
                    ...(0, watch_1.expandCSSPaths)((0, path_1.join)(absSrcPath, 'global')),
                ].filter(Boolean),
            });
            utils_1.lodash.uniq(watcherPaths.map(utils_1.winPath)).forEach((p) => {
                (0, watch_1.watch)({
                    path: p,
                    addToUnWatches: true,
                    onChange: (0, watch_1.createDebouncedHandler)({
                        timeout: 2000,
                        async onChange(opts) {
                            await generate({ files: opts.files, isFirstTime: false });
                        },
                    }),
                });
            });
            // watch package.json change
            const pkgPath = (0, path_1.join)(api.cwd, 'package.json');
            (0, watch_1.watch)({
                path: pkgPath,
                addToUnWatches: true,
                onChange() {
                    const origin = api.appData.pkg;
                    api.appData.pkg = JSON.parse((0, fs_1.readFileSync)(pkgPath, 'utf-8'));
                    api.applyPlugins({
                        key: 'onCheckPkgJSON',
                        args: {
                            origin,
                            current: api.appData.pkg,
                        },
                    });
                    api.applyPlugins({
                        key: 'onPkgJSONChanged',
                        args: {
                            origin,
                            current: api.appData.pkg,
                        },
                    });
                },
            });
            // watch config change
            (0, watch_1.addUnWatch)(api.service.configManager.watch({
                schemas: api.service.configSchemas,
                onChangeTypes: api.service.configOnChanges,
                async onChange(opts) {
                    await api.applyPlugins({
                        key: 'onCheckConfig',
                        args: {
                            config: api.config,
                            userConfig: api.userConfig,
                        },
                    });
                    const { data } = opts;
                    if (data.changes[api.ConfigChangeType.reload]) {
                        utils_1.logger.event(`config ${data.changes[api.ConfigChangeType.reload].join(', ')} changed, restart server...`);
                        api.restartServer();
                        return;
                    }
                    await api.service.resolveConfig();
                    if (data.changes[api.ConfigChangeType.regenerateTmpFiles]) {
                        utils_1.logger.event(`config ${data.changes[api.ConfigChangeType.regenerateTmpFiles].join(', ')} changed, regenerate tmp files...`);
                        await generate({ isFirstTime: false });
                    }
                    for (const fn of data.fns) {
                        fn();
                    }
                },
            }));
            // watch plugin change
            const pluginFiles = [
                (0, path_1.join)(api.cwd, 'plugin.ts'),
                (0, path_1.join)(api.cwd, 'plugin.js'),
            ];
            pluginFiles.forEach((filePath) => {
                (0, watch_1.watch)({
                    path: filePath,
                    addToUnWatches: true,
                    onChange() {
                        utils_1.logger.event(`${(0, path_1.basename)(filePath)} changed, restart server...`);
                        api.restartServer();
                    },
                });
            });
            await api.applyPlugins({
                key: 'onBeforeCompiler',
            });
            // start dev server
            const beforeMiddlewares = await api.applyPlugins({
                key: 'addBeforeMiddlewares',
                initialValue: [],
            });
            const middlewares = await api.applyPlugins({
                key: 'addMiddlewares',
                initialValue: [],
            });
            const { babelPreset, beforeBabelPlugins, beforeBabelPresets, extraBabelPlugins, extraBabelPresets, } = await (0, getBabelOpts_1.getBabelOpts)({ api });
            const chainWebpack = async (memo, args) => {
                await api.applyPlugins({
                    key: 'chainWebpack',
                    type: api.ApplyPluginsType.modify,
                    initialValue: memo,
                    args,
                });
            };
            const modifyWebpackConfig = async (memo, args) => {
                return await api.applyPlugins({
                    key: 'modifyWebpackConfig',
                    initialValue: memo,
                    args,
                });
            };
            const modifyViteConfig = async (memo, args) => {
                return await api.applyPlugins({
                    key: 'modifyViteConfig',
                    initialValue: memo,
                    args,
                });
            };
            const debouncedPrintMemoryUsage = utils_1.lodash.debounce(printMemoryUsage_1.printMemoryUsage, 5000);
            const opts = {
                config: api.config,
                cwd: api.cwd,
                rootDir: process.cwd(),
                entry: {
                    umi: (0, path_1.join)(api.paths.absTmpPath, 'umi.ts'),
                },
                port: api.appData.port,
                host: api.appData.host,
                ...(enableVite
                    ? { modifyViteConfig }
                    : { babelPreset, chainWebpack, modifyWebpackConfig }),
                beforeBabelPlugins,
                beforeBabelPresets,
                extraBabelPlugins,
                extraBabelPresets,
                beforeMiddlewares: [].concat([
                    ...beforeMiddlewares,
                    faviconMiddleware_1.faviconMiddleware,
                ]),
                afterMiddlewares: middlewares.concat((0, createRouteMiddleware_1.createRouteMiddleware)({ api })),
                onDevCompileDone(opts) {
                    debouncedPrintMemoryUsage();
                    api.appData.bundleStatus.done = true;
                    api.applyPlugins({
                        key: 'onDevCompileDone',
                        args: opts,
                    });
                },
                onProgress(opts) {
                    api.appData.bundleStatus.progresses = opts.progresses;
                },
                onMFSUProgress(opts) {
                    api.appData.mfsuBundleStatus = {
                        ...api.appData.mfsuBundleStatus,
                        ...opts,
                    };
                },
                mfsuWithESBuild: (_b = api.config.mfsu) === null || _b === void 0 ? void 0 : _b.esbuild,
                cache: {
                    buildDependencies: [
                        api.pkgPath,
                        api.service.configManager.mainConfigFile || '',
                    ].filter(Boolean),
                },
            };
            if (enableVite) {
                await bundlerVite.dev(opts);
            }
            else {
                await bundlerWebpack.dev(opts);
            }
        },
    });
    api.modifyAppData(async (memo) => {
        memo.port = await utils_1.portfinder.getPortPromise({
            port: parseInt(String(process.env.PORT || constants_1.DEFAULT_PORT), 10),
        });
        memo.host = process.env.HOST || constants_1.DEFAULT_HOST;
        return memo;
    });
    api.registerMethod({
        name: 'restartServer',
        fn() {
            var _a;
            utils_1.logger.info(`Restart dev server with port ${api.appData.port}...`);
            (0, watch_1.unwatch)();
            (_a = process.send) === null || _a === void 0 ? void 0 : _a.call(process, {
                type: 'RESTART',
                payload: {
                    port: api.appData.port,
                },
            });
        },
    });
};
