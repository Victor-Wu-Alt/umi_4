"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const server_1 = require("@umijs/server");
const utils_1 = require("@umijs/utils");
const fs_1 = require("fs");
const path_1 = require("path");
const clearTmp_1 = require("../utils/clearTmp");
const lazyImportFromCurrentPkg_1 = require("../utils/lazyImportFromCurrentPkg");
const getAssetsMap_1 = require("./dev/getAssetsMap");
const getBabelOpts_1 = require("./dev/getBabelOpts");
const getMarkupArgs_1 = require("./dev/getMarkupArgs");
const printMemoryUsage_1 = require("./dev/printMemoryUsage");
const bundlerWebpack = (0, lazyImportFromCurrentPkg_1.lazyImportFromCurrentPkg)('@umijs/bundler-webpack');
const bundlerVite = (0, lazyImportFromCurrentPkg_1.lazyImportFromCurrentPkg)('@umijs/bundler-vite');
exports.default = (api) => {
    api.registerCommand({
        name: 'build',
        description: 'build app for production',
        details: `
umi build

# build without compression
COMPRESS=none umi build

# clean and build
umi build --clean
`,
        fn: async function () {
            utils_1.logger.info(utils_1.chalk.cyan.bold(`Umi v${api.appData.umi.version}`));
            // clear tmp except cache
            (0, clearTmp_1.clearTmp)(api.paths.absTmpPath);
            // check package.json
            await api.applyPlugins({
                key: 'onCheckPkgJSON',
                args: {
                    origin: null,
                    current: api.appData.pkg,
                },
            });
            // generate files
            async function generate(opts) {
                await api.applyPlugins({
                    key: 'onGenerateFiles',
                    args: {
                        files: opts.files || null,
                        isFirstTime: opts.isFirstTime,
                    },
                });
            }
            await generate({
                isFirstTime: true,
            });
            await api.applyPlugins({
                key: 'onBeforeCompiler',
            });
            // build
            // TODO: support watch mode
            const { babelPreset, beforeBabelPlugins, beforeBabelPresets, extraBabelPlugins, extraBabelPresets, } = await (0, getBabelOpts_1.getBabelOpts)({ api });
            const chainWebpack = async (memo, args) => {
                await api.applyPlugins({
                    key: 'chainWebpack',
                    type: api.ApplyPluginsType.modify,
                    initialValue: memo,
                    args,
                });
            };
            const modifyWebpackConfig = async (memo, args) => {
                return await api.applyPlugins({
                    key: 'modifyWebpackConfig',
                    initialValue: memo,
                    args,
                });
            };
            const modifyViteConfig = async (memo, args) => {
                return await api.applyPlugins({
                    key: 'modifyViteConfig',
                    initialValue: memo,
                    args,
                });
            };
            const opts = {
                config: api.config,
                cwd: api.cwd,
                entry: {
                    umi: (0, path_1.join)(api.paths.absTmpPath, 'umi.ts'),
                },
                ...(api.config.vite
                    ? { modifyViteConfig }
                    : { babelPreset, chainWebpack, modifyWebpackConfig }),
                beforeBabelPlugins,
                beforeBabelPresets,
                extraBabelPlugins,
                extraBabelPresets,
                onBuildComplete(opts) {
                    (0, printMemoryUsage_1.printMemoryUsage)();
                    api.applyPlugins({
                        key: 'onBuildComplete',
                        args: opts,
                    });
                },
                clean: api.args.clean,
            };
            let stats;
            if (api.config.vite) {
                stats = await bundlerVite.build(opts);
            }
            else {
                stats = await bundlerWebpack.build(opts);
            }
            // generate html
            // vite 在 build 时通过插件注入 js 和 css
            const assetsMap = api.config.vite
                ? {}
                : (0, getAssetsMap_1.getAssetsMap)({
                    stats,
                    publicPath: api.config.publicPath,
                });
            const { vite } = api.args;
            const markupArgs = await (0, getMarkupArgs_1.getMarkupArgs)({ api });
            // @ts-ignore
            const markup = await (0, server_1.getMarkup)({
                ...markupArgs,
                styles: (api.config.vite ? [] : assetsMap['umi.css'] || []).concat(markupArgs.styles),
                scripts: (api.config.vite ? [] : assetsMap['umi.js'] || []).concat(markupArgs.scripts),
                esmScript: !!opts.config.esm || vite,
                path: '/',
            });
            (0, fs_1.writeFileSync)((0, path_1.join)(api.paths.absOutputPath, 'index.html'), markup, 'utf-8');
            utils_1.logger.event('Build index.html');
            // event when html is completed
            await api.applyPlugins({
                key: 'onBuildHtmlComplete',
                args: opts,
            });
            // print size
        },
    });
};
