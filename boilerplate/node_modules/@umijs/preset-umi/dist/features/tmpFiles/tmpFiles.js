"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@umijs/utils");
const fs_1 = require("fs");
const path_1 = require("path");
const constants_1 = require("../../constants");
const getModuleExports_1 = require("./getModuleExports");
const importsToStr_1 = require("./importsToStr");
const routes_1 = require("./routes");
exports.default = (api) => {
    api.describe({
        key: 'tmpFiles',
        config: {
            schema(Joi) {
                return Joi.boolean();
            },
        },
    });
    api.onGenerateFiles(async (opts) => {
        var _a;
        const rendererPath = (0, utils_1.winPath)(await api.applyPlugins({
            key: 'modifyRendererPath',
            initialValue: (0, path_1.dirname)(require.resolve('@umijs/renderer-react/package.json')),
        }));
        // umi.ts
        api.writeTmpFile({
            noPluginDir: true,
            path: 'umi.ts',
            tplPath: (0, path_1.join)(constants_1.TEMPLATES_DIR, 'umi.tpl'),
            context: {
                mountElementId: api.config.mountElementId,
                rendererPath,
                publicPath: api.config.publicPath,
                runtimePublicPath: api.config.runtimePublicPath ? 'true' : 'false',
                entryCode: (await api.applyPlugins({
                    key: 'addEntryCode',
                    initialValue: [],
                })).join('\n'),
                entryCodeAhead: (await api.applyPlugins({
                    key: 'addEntryCodeAhead',
                    initialValue: [],
                })).join('\n'),
                polyfillImports: (0, importsToStr_1.importsToStr)(await api.applyPlugins({
                    key: 'addPolyfillImports',
                    initialValue: [],
                })).join('\n'),
                importsAhead: (0, importsToStr_1.importsToStr)(await api.applyPlugins({
                    key: 'addEntryImportsAhead',
                    initialValue: [
                        api.appData.globalCSS.length && {
                            source: api.appData.globalCSS[0],
                        },
                        api.appData.globalJS.length && {
                            source: api.appData.globalJS[0],
                        },
                    ].filter(Boolean),
                })).join('\n'),
                imports: (0, importsToStr_1.importsToStr)(await api.applyPlugins({
                    key: 'addEntryImports',
                    initialValue: [],
                })).join('\n'),
                basename: api.config.base,
                historyType: api.config.history.type,
                loadingComponent: (0, fs_1.existsSync)((0, path_1.join)(api.paths.absSrcPath, 'loading.tsx')) ||
                    (0, fs_1.existsSync)((0, path_1.join)(api.paths.absSrcPath, 'loading.jsx')) ||
                    (0, fs_1.existsSync)((0, path_1.join)(api.paths.absSrcPath, 'loading.js')),
            },
        });
        // EmptyRoute.tsx
        api.writeTmpFile({
            noPluginDir: true,
            path: 'core/EmptyRoute.tsx',
            content: `
import { Outlet } from 'umi';
export default function EmptyRoute() {
  return <Outlet />;
}
      `,
        });
        // route.ts
        let routes;
        if (opts.isFirstTime) {
            routes = api.appData.routes;
        }
        else {
            routes = await (0, routes_1.getRoutes)({
                api,
            });
        }
        const hasSrc = api.appData.hasSrcDir;
        // @/pages/
        const pages = (0, path_1.basename)(((_a = api.config.conventionRoutes) === null || _a === void 0 ? void 0 : _a.base) || api.paths.absPagesPath);
        const prefix = hasSrc ? `../../../src/${pages}/` : `../../${pages}/`;
        const clonedRoutes = utils_1.lodash.cloneDeep(routes);
        for (const id of Object.keys(clonedRoutes)) {
            for (const key of Object.keys(clonedRoutes[id])) {
                const route = clonedRoutes[id];
                // Remove __ prefix props and absPath props
                if (key.startsWith('__') || key.startsWith('absPath')) {
                    delete route[key];
                }
            }
        }
        api.writeTmpFile({
            noPluginDir: true,
            path: 'core/route.tsx',
            tplPath: (0, path_1.join)(constants_1.TEMPLATES_DIR, 'route.tpl'),
            context: {
                isClientLoaderEnabled: !!api.config.clientLoader,
                routes: JSON.stringify(clonedRoutes)
                    // "clientLoaders['foo']" > clientLoaders['foo']
                    .replace(/"(clientLoaders\[.*?)"/g, '$1'),
                routeComponents: await (0, routes_1.getRouteComponents)({ routes, prefix, api }),
            },
        });
        // plugin.ts
        const plugins = await api.applyPlugins({
            key: 'addRuntimePlugin',
            initialValue: [
                (0, utils_1.tryPaths)([
                    (0, path_1.join)(api.paths.absSrcPath, 'app.ts'),
                    (0, path_1.join)(api.paths.absSrcPath, 'app.tsx'),
                    (0, path_1.join)(api.paths.absSrcPath, 'app.jsx'),
                    (0, path_1.join)(api.paths.absSrcPath, 'app.js'),
                ]),
            ].filter(Boolean),
        });
        const validKeys = await api.applyPlugins({
            key: 'addRuntimePluginKey',
            initialValue: [
                'patchRoutes',
                'patchClientRoutes',
                'modifyContextOpts',
                'rootContainer',
                'innerProvider',
                'i18nProvider',
                'accessProvider',
                'dataflowProvider',
                'outerProvider',
                'render',
                'onRouteChange',
            ],
        });
        api.writeTmpFile({
            noPluginDir: true,
            path: 'core/plugin.ts',
            tplPath: (0, path_1.join)(constants_1.TEMPLATES_DIR, 'plugin.tpl'),
            context: {
                plugins: plugins.map((plugin, index) => ({
                    index,
                    path: (0, utils_1.winPath)(plugin),
                })),
                validKeys,
            },
        });
        // history.ts
        api.writeTmpFile({
            noPluginDir: true,
            path: 'core/history.ts',
            tplPath: (0, path_1.join)(constants_1.TEMPLATES_DIR, 'history.tpl'),
            context: {
                rendererPath,
            },
        });
    });
    function checkMembers(opts) {
        const conflicts = utils_1.lodash.intersection(opts.exportMembers, opts.members);
        if (conflicts.length) {
            throw new Error(`Conflict members: ${conflicts.join(', ')} in ${opts.path}`);
        }
    }
    async function getExportsAndCheck(opts) {
        const members = (await (0, getModuleExports_1.getModuleExports)({ file: opts.path }));
        checkMembers({
            members,
            exportMembers: opts.exportMembers,
            path: opts.path,
        });
        opts.exportMembers.push(...members);
        return members;
    }
    // Generate @@/exports.ts
    api.register({
        key: 'onGenerateFiles',
        fn: async () => {
            const rendererPath = (0, utils_1.winPath)(await api.applyPlugins({
                key: 'modifyRendererPath',
                initialValue: (0, path_1.dirname)(require.resolve('@umijs/renderer-react/package.json')),
            }));
            const exports = [];
            const exportMembers = ['default'];
            // @umijs/renderer-react
            exports.push('// @umijs/renderer-*');
            exports.push(`export { ${(await getExportsAndCheck({
                path: (0, path_1.join)(rendererPath, 'dist/index.js'),
                exportMembers,
            })).join(', ')} } from '${rendererPath}';`);
            // umi/client/client/plugin
            exports.push('// umi/client/client/plugin');
            const umiDir = process.env.UMI_DIR;
            const umiPluginPath = (0, utils_1.winPath)((0, path_1.join)(umiDir, 'client/client/plugin.js'));
            exports.push(`export { ${(await getExportsAndCheck({
                path: umiPluginPath,
                exportMembers,
            })).join(', ')} } from '${umiPluginPath}';`);
            // @@/core/history.ts
            exports.push(`export { history, createHistory } from './core/history';`);
            checkMembers({
                members: ['history', 'createHistory'],
                exportMembers,
                path: '@@/core/history.ts',
            });
            // @@/core/terminal.ts
            if (api.service.config.terminal !== false) {
                exports.push(`export { terminal } from './core/terminal';`);
                checkMembers({
                    members: ['terminal'],
                    exportMembers,
                    path: '@@/core/terminal.ts',
                });
            }
            // plugins
            exports.push('// plugins');
            const plugins = (0, fs_1.readdirSync)(api.paths.absTmpPath).filter((file) => {
                if (file.startsWith('plugin-') &&
                    ((0, fs_1.existsSync)((0, path_1.join)(api.paths.absTmpPath, file, 'index.ts')) ||
                        (0, fs_1.existsSync)((0, path_1.join)(api.paths.absTmpPath, file, 'index.tsx')))) {
                    return true;
                }
            });
            for (const plugin of plugins) {
                let file;
                if ((0, fs_1.existsSync)((0, path_1.join)(api.paths.absTmpPath, plugin, 'index.ts'))) {
                    file = (0, path_1.join)(api.paths.absTmpPath, plugin, 'index.ts');
                }
                if ((0, fs_1.existsSync)((0, path_1.join)(api.paths.absTmpPath, plugin, 'index.tsx'))) {
                    file = (0, path_1.join)(api.paths.absTmpPath, plugin, 'index.tsx');
                }
                const pluginExports = await getExportsAndCheck({
                    path: file,
                    exportMembers,
                });
                if (pluginExports.length) {
                    exports.push(`export { ${pluginExports.join(', ')} } from '${(0, utils_1.winPath)((0, path_1.join)(api.paths.absTmpPath, plugin))}';`);
                }
            }
            // plugins types.ts
            exports.push('// plugins types.d.ts');
            for (const plugin of plugins) {
                const file = (0, utils_1.winPath)((0, path_1.join)(api.paths.absTmpPath, plugin, 'types.d.ts'));
                if ((0, fs_1.existsSync)(file)) {
                    // 带 .ts 后缀的声明文件 会导致声明失效
                    const noSuffixFile = file.replace(/\.ts$/, '');
                    exports.push(`export * from '${noSuffixFile}';`);
                }
            }
            api.writeTmpFile({
                noPluginDir: true,
                path: 'exports.ts',
                content: exports.join('\n'),
            });
        },
        stage: Infinity,
    });
};
