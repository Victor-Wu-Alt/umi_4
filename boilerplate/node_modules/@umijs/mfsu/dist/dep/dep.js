"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Dep = void 0;
const utils_1 = require("@umijs/utils");
const assert_1 = __importDefault(require("assert"));
const enhanced_resolve_1 = __importDefault(require("enhanced-resolve"));
const fs_1 = require("fs");
const path_1 = require("path");
const constants_1 = require("../constants");
const trimFileContent_1 = require("../utils/trimFileContent");
const getExposeFromContent_1 = require("./getExposeFromContent");
const resolver = enhanced_resolve_1.default.create({
    mainFields: ['module', 'browser', 'main'],
    extensions: ['.wasm', '.mjs', '.js', '.jsx', '.ts', '.tsx', '.json'],
    exportsFields: ['exports'],
    conditionNames: ['import', 'module', 'require', 'node'],
});
async function resolve(context, path) {
    return new Promise((resolve, reject) => {
        resolver(context, path, (err, result) => err ? reject(err) : resolve(result));
    });
}
class Dep {
    constructor(opts) {
        this.file = (0, utils_1.winPath)(opts.file);
        this.version = opts.version;
        this.cwd = opts.cwd;
        this.shortFile = this.file;
        this.normalizedFile = this.shortFile.replace(/\//g, '_').replace(/:/g, '_');
        this.filePath = `${constants_1.MF_VA_PREFIX}${this.normalizedFile}.js`;
        this.mfsu = opts.mfsu;
    }
    async buildExposeContent() {
        // node natives
        // @ts-ignore
        const isNodeNatives = !!process.binding('natives')[this.file];
        if (isNodeNatives) {
            return (0, trimFileContent_1.trimFileContent)(this.mfsu.opts.excludeNodeNatives
                ? `
const _ = require('${this.file}');
module.exports = _;
      `
                : `
import _ from '${this.file}';
export default _;
export * from '${this.file}';
      `);
        }
        // none node natives
        const realFile = await this.getRealFile();
        (0, assert_1.default)(realFile, `filePath not found of ${this.file}`);
        const content = (0, fs_1.readFileSync)(realFile, 'utf-8');
        return await (0, getExposeFromContent_1.getExposeFromContent)({
            content,
            filePath: realFile,
            dep: this,
        });
    }
    async getRealFile() {
        try {
            // don't need to handle alias here
            // it's already handled by babel plugin
            return await resolve(this.cwd, this.file);
        }
        catch (e) {
            return null;
        }
    }
    static buildDeps(opts) {
        return Object.keys(opts.deps).map((file) => {
            return new Dep({
                ...opts.deps[file],
                cwd: opts.cwd,
                mfsu: opts.mfsu,
            });
        });
    }
    static getDepVersion(opts) {
        // @ts-ignore
        if (!!process.binding('natives')[opts.dep]) {
            return '*';
        }
        const dep = (0, path_1.isAbsolute)(opts.dep)
            ? opts.dep
            : (0, path_1.join)(opts.cwd, 'node_modules', opts.dep);
        const pkg = utils_1.pkgUp.pkgUpSync({
            cwd: dep,
        });
        (0, assert_1.default)(pkg, `package.json not found for ${opts.dep}`);
        return require(pkg).version;
    }
}
exports.Dep = Dep;
