"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Service = void 0;
const tapable_1 = require("@umijs/bundler-utils/compiled/tapable");
const utils_1 = require("@umijs/utils");
const assert_1 = __importDefault(require("assert"));
const fs_1 = require("fs");
const path_1 = require("path");
const config_1 = require("../config/config");
const constants_1 = require("../constants");
const types_1 = require("../types");
const env_1 = require("./env");
const path_2 = require("./path");
const plugin_1 = require("./plugin");
const pluginAPI_1 = require("./pluginAPI");
class Service {
    constructor(opts) {
        this.appData = {};
        this.args = { _: [], $0: '' };
        this.commands = {};
        this.generators = {};
        this.config = {};
        this.configSchemas = {};
        this.configDefaults = {};
        this.configOnChanges = {};
        this.hooks = {};
        this.name = '';
        this.paths = {};
        // preset is plugin with different type
        this.plugins = {};
        this.keyToPluginMap = {};
        this.pluginMethods = {};
        this.skipPluginIds = new Set();
        this.stage = types_1.ServiceStage.uninitialized;
        this.userConfig = {};
        this.configManager = null;
        this.pkg = {};
        this.pkgPath = '';
        this.cwd = opts.cwd;
        this.env = opts.env;
        this.opts = opts;
        (0, assert_1.default)((0, fs_1.existsSync)(this.cwd), `Invalid cwd ${this.cwd}, it's not found.`);
    }
    applyPlugins(opts) {
        const hooks = this.hooks[opts.key] || [];
        let type = opts.type;
        // guess type from key
        if (!type) {
            if (opts.key.startsWith('on')) {
                type = types_1.ApplyPluginsType.event;
            }
            else if (opts.key.startsWith('modify')) {
                type = types_1.ApplyPluginsType.modify;
            }
            else if (opts.key.startsWith('add')) {
                type = types_1.ApplyPluginsType.add;
            }
            else {
                throw new Error(`Invalid applyPlugins arguments, type must be supplied for key ${opts.key}.`);
            }
        }
        switch (type) {
            case types_1.ApplyPluginsType.add:
                (0, assert_1.default)(!('initialValue' in opts) || Array.isArray(opts.initialValue), `applyPlugins failed, opts.initialValue must be Array if opts.type is add.`);
                const tAdd = new tapable_1.AsyncSeriesWaterfallHook(['memo']);
                for (const hook of hooks) {
                    if (!this.isPluginEnable(hook))
                        continue;
                    tAdd.tapPromise({
                        name: hook.plugin.key,
                        stage: hook.stage || 0,
                        before: hook.before,
                    }, async (memo) => {
                        var _a, _b;
                        const dateStart = new Date();
                        const items = await hook.fn(opts.args);
                        (_a = hook.plugin.time.hooks)[_b = opts.key] || (_a[_b] = []);
                        hook.plugin.time.hooks[opts.key].push(new Date().getTime() - dateStart.getTime());
                        return memo.concat(items);
                    });
                }
                return tAdd.promise(opts.initialValue || []);
            case types_1.ApplyPluginsType.modify:
                const tModify = new tapable_1.AsyncSeriesWaterfallHook(['memo']);
                for (const hook of hooks) {
                    if (!this.isPluginEnable(hook))
                        continue;
                    tModify.tapPromise({
                        name: hook.plugin.key,
                        stage: hook.stage || 0,
                        before: hook.before,
                    }, async (memo) => {
                        var _a, _b;
                        const dateStart = new Date();
                        const ret = await hook.fn(memo, opts.args);
                        (_a = hook.plugin.time.hooks)[_b = opts.key] || (_a[_b] = []);
                        hook.plugin.time.hooks[opts.key].push(new Date().getTime() - dateStart.getTime());
                        return ret;
                    });
                }
                return tModify.promise(opts.initialValue);
            case types_1.ApplyPluginsType.event:
                if (opts.sync) {
                    const tEvent = new tapable_1.SyncWaterfallHook(['_']);
                    hooks.forEach((hook) => {
                        if (this.isPluginEnable(hook)) {
                            tEvent.tap({
                                name: hook.plugin.key,
                                stage: hook.stage || 0,
                                before: hook.before,
                            }, () => {
                                var _a, _b;
                                const dateStart = new Date();
                                hook.fn(opts.args);
                                (_a = hook.plugin.time.hooks)[_b = opts.key] || (_a[_b] = []);
                                hook.plugin.time.hooks[opts.key].push(new Date().getTime() - dateStart.getTime());
                            });
                        }
                    });
                    return tEvent.call(1);
                }
                const tEvent = new tapable_1.AsyncSeriesWaterfallHook(['_']);
                for (const hook of hooks) {
                    if (!this.isPluginEnable(hook))
                        continue;
                    tEvent.tapPromise({
                        name: hook.plugin.key,
                        stage: hook.stage || 0,
                        before: hook.before,
                    }, async () => {
                        var _a, _b;
                        const dateStart = new Date();
                        await hook.fn(opts.args);
                        (_a = hook.plugin.time.hooks)[_b = opts.key] || (_a[_b] = []);
                        hook.plugin.time.hooks[opts.key].push(new Date().getTime() - dateStart.getTime());
                    });
                }
                return tEvent.promise(1);
            default:
                throw new Error(`applyPlugins failed, type is not defined or is not matched, got ${opts.type}.`);
        }
    }
    async run(opts) {
        const { name, args = {} } = opts;
        args._ = args._ || [];
        // shift the command itself
        if (args._[0] === name)
            args._.shift();
        this.args = args;
        this.name = name;
        // loadEnv
        this.stage = types_1.ServiceStage.init;
        (0, env_1.loadEnv)({ cwd: this.cwd, envFile: '.env' });
        // get pkg from package.json
        let pkg = {};
        let pkgPath = '';
        try {
            pkg = require((0, path_1.join)(this.cwd, 'package.json'));
            pkgPath = (0, path_1.join)(this.cwd, 'package.json');
        }
        catch (_e) {
            // APP_ROOT
            if (this.cwd !== process.cwd()) {
                try {
                    pkg = require((0, path_1.join)(process.cwd(), 'package.json'));
                    pkgPath = (0, path_1.join)(process.cwd(), 'package.json');
                }
                catch (_e) { }
            }
        }
        this.pkg = pkg;
        this.pkgPath = pkgPath || (0, path_1.join)(this.cwd, 'package.json');
        const prefix = this.opts.frameworkName || constants_1.DEFAULT_FRAMEWORK_NAME;
        // get user config
        const configManager = new config_1.Config({
            cwd: this.cwd,
            env: this.env,
            defaultConfigFiles: this.opts.defaultConfigFiles,
            specifiedEnv: process.env[`${prefix}_ENV`.toUpperCase()],
        });
        this.configManager = configManager;
        this.userConfig = configManager.getUserConfig().config;
        // get paths
        const paths = (0, path_2.getPaths)({
            cwd: this.cwd,
            env: this.env,
            prefix: this.opts.frameworkName || constants_1.DEFAULT_FRAMEWORK_NAME,
        });
        // temporary paths for use by function generateFinalConfig.
        // the value of paths may be updated by plugins later
        this.paths = paths;
        // resolve initial presets and plugins
        const { plugins, presets } = plugin_1.Plugin.getPluginsAndPresets({
            cwd: this.cwd,
            pkg,
            plugins: [require.resolve('./generatePlugin')].concat(this.opts.plugins || []),
            presets: [require.resolve('./servicePlugin')].concat(this.opts.presets || []),
            userConfig: this.userConfig,
            prefix,
        });
        // register presets and plugins
        this.stage = types_1.ServiceStage.initPresets;
        const presetPlugins = [];
        while (presets.length) {
            await this.initPreset({
                preset: presets.shift(),
                presets,
                plugins: presetPlugins,
            });
        }
        plugins.unshift(...presetPlugins);
        this.stage = types_1.ServiceStage.initPlugins;
        while (plugins.length) {
            await this.initPlugin({ plugin: plugins.shift(), plugins });
        }
        const command = this.commands[name];
        (0, assert_1.default)(command, `Invalid command ${name}, it's not registered.`);
        // collect configSchemas and configDefaults
        for (const id of Object.keys(this.plugins)) {
            const { config, key } = this.plugins[id];
            if (config.schema)
                this.configSchemas[key] = config.schema;
            if (config.default !== undefined) {
                this.configDefaults[key] = config.default;
            }
            this.configOnChanges[key] = config.onChange || types_1.ConfigChangeType.reload;
        }
        // setup api.config from modifyConfig and modifyDefaultConfig
        this.stage = types_1.ServiceStage.resolveConfig;
        const { config, defaultConfig } = await this.resolveConfig();
        if (this.config.outputPath) {
            paths.absOutputPath = (0, path_1.isAbsolute)(this.config.outputPath)
                ? this.config.outputPath
                : (0, path_1.join)(this.cwd, this.config.outputPath);
        }
        this.paths = await this.applyPlugins({
            key: 'modifyPaths',
            initialValue: paths,
        });
        // applyPlugin collect app data
        // TODO: some data is mutable
        this.stage = types_1.ServiceStage.collectAppData;
        this.appData = await this.applyPlugins({
            key: 'modifyAppData',
            initialValue: {
                // base
                cwd: this.cwd,
                pkg,
                pkgPath,
                plugins,
                presets,
                name,
                args,
                // config
                userConfig: this.userConfig,
                mainConfigFile: configManager.mainConfigFile,
                config,
                defaultConfig: defaultConfig,
                // TODO
                // moduleGraph,
                // routes,
                // npmClient,
                // nodeVersion,
                // gitInfo,
                // gitBranch,
                // debugger info,
                // devPort,
                // devHost,
                // env
            },
        });
        // applyPlugin onCheck
        this.stage = types_1.ServiceStage.onCheck;
        await this.applyPlugins({
            key: 'onCheck',
        });
        // applyPlugin onStart
        this.stage = types_1.ServiceStage.onStart;
        await this.applyPlugins({
            key: 'onStart',
        });
        // run command
        this.stage = types_1.ServiceStage.runCommand;
        let ret = await command.fn({ args });
        this._baconPlugins();
        return ret;
    }
    async resolveConfig() {
        // configManager and paths are not available until the init stage
        (0, assert_1.default)(this.stage > types_1.ServiceStage.init, `Can't generate final config before init stage`);
        const resolveMode = this.commands[this.name].configResolveMode;
        const config = await this.applyPlugins({
            key: 'modifyConfig',
            // why clone deep?
            // user may change the config in modifyConfig
            // e.g. memo.alias = xxx
            initialValue: utils_1.lodash.cloneDeep(resolveMode === 'strict'
                ? this.configManager.getConfig({
                    schemas: this.configSchemas,
                }).config
                : this.configManager.getUserConfig().config),
            args: { paths: this.paths },
        });
        const defaultConfig = await this.applyPlugins({
            key: 'modifyDefaultConfig',
            initialValue: this.configDefaults,
        });
        this.config = utils_1.lodash.merge(defaultConfig, config);
        return { config, defaultConfig };
    }
    _baconPlugins() {
        // TODO: prettier
        if (this.args.baconPlugins) {
            console.log();
            for (const id of Object.keys(this.plugins)) {
                const plugin = this.plugins[id];
                console.log(utils_1.chalk.green('plugin'), plugin.id, plugin.time);
            }
        }
    }
    async initPreset(opts) {
        const { presets, plugins } = await this.initPlugin({
            plugin: opts.preset,
            presets: opts.presets,
            plugins: opts.plugins,
        });
        opts.presets.unshift(...(presets || []));
        opts.plugins.push(...(plugins || []));
    }
    async initPlugin(opts) {
        var _a, _b;
        // register to this.plugins
        (0, assert_1.default)(!this.plugins[opts.plugin.id], `${opts.plugin.type} ${opts.plugin.id} is already registered by ${(_a = this.plugins[opts.plugin.id]) === null || _a === void 0 ? void 0 : _a.path}, ${opts.plugin.type} from ${opts.plugin.path} register failed.`);
        this.plugins[opts.plugin.id] = opts.plugin;
        // apply with PluginAPI
        const pluginAPI = new pluginAPI_1.PluginAPI({
            plugin: opts.plugin,
            service: this,
        });
        pluginAPI.registerPresets = pluginAPI.registerPresets.bind(pluginAPI, opts.presets || []);
        pluginAPI.registerPlugins = pluginAPI.registerPlugins.bind(pluginAPI, opts.plugins);
        const proxyPluginAPI = pluginAPI_1.PluginAPI.proxyPluginAPI({
            service: this,
            pluginAPI,
            serviceProps: [
                'appData',
                'applyPlugins',
                'args',
                'config',
                'cwd',
                'pkg',
                'pkgPath',
                'name',
                'paths',
                'userConfig',
                'env',
                'isPluginEnable',
            ],
            staticProps: {
                ApplyPluginsType: types_1.ApplyPluginsType,
                ConfigChangeType: types_1.ConfigChangeType,
                EnableBy: types_1.EnableBy,
                ServiceStage: types_1.ServiceStage,
                service: this,
            },
        });
        let dateStart = new Date();
        let ret = await opts.plugin.apply()(proxyPluginAPI);
        opts.plugin.time.register = new Date().getTime() - dateStart.getTime();
        if (opts.plugin.type === 'plugin') {
            (0, assert_1.default)(!ret, `plugin should return nothing`);
        }
        // key should be unique
        (0, assert_1.default)(!this.keyToPluginMap[opts.plugin.key], `key ${opts.plugin.key} is already registered by ${(_b = this.keyToPluginMap[opts.plugin.key]) === null || _b === void 0 ? void 0 : _b.path}, ${opts.plugin.type} from ${opts.plugin.path} register failed.`);
        this.keyToPluginMap[opts.plugin.key] = opts.plugin;
        if (ret === null || ret === void 0 ? void 0 : ret.presets) {
            ret.presets = ret.presets.map((preset) => new plugin_1.Plugin({
                path: preset,
                type: types_1.PluginType.preset,
                cwd: this.cwd,
            }));
        }
        if (ret === null || ret === void 0 ? void 0 : ret.plugins) {
            ret.plugins = ret.plugins.map((plugin) => new plugin_1.Plugin({
                path: plugin,
                type: types_1.PluginType.plugin,
                cwd: this.cwd,
            }));
        }
        return ret || {};
    }
    isPluginEnable(hook) {
        let plugin;
        if (hook.plugin) {
            plugin = hook.plugin;
        }
        else {
            plugin = this.keyToPluginMap[hook];
        }
        const { id, key, enableBy } = plugin;
        if (this.skipPluginIds.has(id))
            return false;
        if (this.userConfig[key] === false)
            return false;
        if (this.config[key] === false)
            return false;
        if (enableBy === types_1.EnableBy.config) {
            // TODO: 提供单独的命令用于启用插件
            // this.userConfig 中如果存在，启用
            // this.config 好了之后如果存在，启用
            // this.config 在 modifyConfig 和 modifyDefaultConfig 之后才会 ready
            // 这意味着 modifyConfig 和 modifyDefaultConfig 只能判断 api.userConfig
            // 举个具体场景:
            //   - p1 enableBy config, p2 modifyDefaultConfig p1 = {}
            //   - p1 里 modifyConfig 和 modifyDefaultConfig 仅 userConfig 里有 p1 有效，其他 p2 开启时即有效
            //   - p2 里因为用了 modifyDefaultConfig，如果 p2 是 enableBy config，需要 userConfig 里配 p2，p2 和 p1 才有效
            return key in this.userConfig || (this.config && key in this.config);
        }
        if (typeof enableBy === 'function')
            return enableBy({
                userConfig: this.userConfig,
                config: this.config,
                env: this.env,
            });
        // EnableBy.register
        return true;
    }
}
exports.Service = Service;
